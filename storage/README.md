# Storage Layer

The storage layer provides a clean abstraction for data persistence in the knowledge graph, separating infrastructure concerns (database operations) from domain logic (data processing).

## Architecture

The storage layer is organized into three main components:

```
storage/
├── interfaces.py           # Abstract base class defining storage contract (`StorageInterface`)
├── backends/              # Concrete backend implementations
│   ├── sqlite.py          # SQLite implementation for development/testing
│   └── postgres.py        # PostgreSQL for production
└── models/                # SQLModel persistence schemas
    ├── entity.py          # Generic Entity table
    └── relationship.py    # Generic Relationship table
```

## Key Concepts

### Storage Abstraction

The storage layer uses a single abstract interface (`StorageInterface`) that allows the application to work with different storage backends without code changes. This enables:

- **Development flexibility**: Use SQLite for local development and testing
- **Production scalability**: Switch to PostgreSQL for production
- **Easy testing**: Mock storage backends for unit tests
- **Future extensibility**: Add new backends (Neo4j, MongoDB, etc.) without changing core application code

## Quick Start

### SQLite (Development/Testing)

```python
from storage.backends.sqlite import SQLiteStorage
from storage.models.entity import Entity
from storage.models.relationship import Relationship
from query.bundle import BundleManifestV1
import datetime

# Create in-memory database (or a file path)
storage = SQLiteStorage(":memory:")

# Example BundleManifest (replace with actual loaded manifest)
manifest = BundleManifestV1(
    bundle_version="v1",
    domain="test",
    created_at=datetime.datetime.now(),
    bundle_id="test_bundle_123",
    entities={"path": "entities.jsonl", "format": "jsonl"},
    relationships={"path": "relationships.jsonl", "format": "jsonl"},
)

# Placeholder: In a real scenario, entities.jsonl and relationships.jsonl
# would be files containing your data.
# For this example, we'll manually create some data and simulate loading.
# (You'd typically have these files generated by a data bundling process)

# Simulate creating bundle files
with open("entities.jsonl", "w") as f:
    f.write('{"entity_id": "E001", "entity_type": "person", "name": "Alice"}\n')
    f.write('{"entity_id": "E002", "entity_type": "person", "name": "Bob"}\n')
with open("relationships.jsonl", "w") as f:
    f.write('{"subject_id": "E001", "predicate": "knows", "object_id": "E002"}\n')

# Load the bundle (assuming 'entities.jsonl' and 'relationships.jsonl' are in the current dir)
storage.load_bundle(manifest, ".")

# Retrieve entities
entity_alice = storage.get_entity("E001")
print(f"Found: {entity_alice.name}")

# Find relationships
relationships = storage.find_relationships(subject_id="E001")
for rel in relationships:
    print(f"Relationship: {rel.subject_id} {rel.predicate} {rel.object_id}")

# Don't forget to close
storage.close()
```

### PostgreSQL (Production)

```python
from storage.backends.postgres import PostgresStorage
from sqlmodel import create_engine, Session
from query.bundle import BundleManifestV1
import datetime

# Connect to PostgreSQL
DATABASE_URL = "postgresql://user:password@localhost:5432/mydatabase"
engine = create_engine(DATABASE_URL)
session = Session(engine)
storage = PostgresStorage(session)

# Example BundleManifest
manifest = BundleManifestV1(
    bundle_version="v1",
    domain="test",
    created_at=datetime.datetime.now(),
    bundle_id="test_bundle_123",
    entities={"path": "entities.jsonl", "format": "jsonl"},
    relationships={"path": "relationships.jsonl", "format": "jsonl"},
)

# Load the bundle (assuming 'entities.jsonl' and 'relationships.jsonl' are in the current dir)
# In a real setup, bundle files would be mounted to the container.
storage.load_bundle(manifest, ".")

# Same API as SQLite
entity_alice = storage.get_entity("E001")
print(f"Found: {entity_alice.name}")

storage.close()
```

## When to Use Which Backend

### SQLite
**Use for:**
- Local development
- Testing and CI/CD
- Small datasets
- Single-user applications
- Prototyping

**Advantages:**
- No setup required
- Fast for small datasets
- Portable (single file)
- Great for testing

**Limitations:**
- Limited concurrency
- Not designed for large-scale production deployments

### PostgreSQL
**Use for:**
- Production deployments
- Large datasets
- Multi-user applications
- When you need robust concurrent access

**Advantages:**
- Excellent performance at scale
- Concurrent read/write support
- Advanced indexing and query optimization
- JSONB support for flexible schemas

**Setup Required:**
- PostgreSQL installation and configuration

## Directory Structure

- **`interfaces.py`**: Abstract base class defining the `StorageInterface`
- **`backends/`**: Concrete implementations for different databases
  - See [backends/README.md](backends/README.md) for backend comparison
- **`models/`**: SQLModel schemas for database persistence
  - See [models/README.md](models/README.md) for schema documentation

## Testing

Storage layer tests are organized in `tests/storage/`:

```bash
# Run all storage tests
pytest tests/storage/ -v

# Test specific backend
pytest tests/storage/backends/test_sqlite.py -v

# Test models
pytest tests/storage/models/test_entity.py -v
```

## Further Reading

- [Storage Backends Comparison](backends/README.md)
- [Database Schema Documentation](models/README.md)
- [Neo4j Compatibility Guide](NEO4J_COMPATIBILITY.md)